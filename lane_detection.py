# -*- coding: utf-8 -*-
"""lane_detection.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ea6GI9-Ui5LwrDzosFNr7YcFxnHSkxdC
"""

import matplotlib.pyplot as plt
import numpy as np
import cv2
import math
from moviepy.editor import VideoFileClip
from IPython.display import HTML

class LaneDetector:
    def _init_(self):
        self.left_line = None
        self.right_line = None

    def region_of_interest(self, img, vertices):
        mask = np.zeros_like(img)
        match_mask_color = 255
        cv2.fillPoly(mask, vertices, match_mask_color)
        masked_image = cv2.bitwise_and(img, mask)
        return masked_image

    def draw_lines(self, img, lines, color=[255, 0, 0], thickness=3):
        line_img = np.zeros((img.shape[0], img.shape[1], 3), dtype=np.uint8)
        img = np.copy(img)
        if lines is None:
            return img
        for line in lines:
            for x1, y1, x2, y2 in line:
                cv2.line(line_img, (x1, y1), (x2, y2), color, thickness)
        img = cv2.addWeighted(img, 0.8, line_img, 1.0, 0.0)
        return img

    def detect_cars(self, image):
        car_cascade = cv2.CascadeClassifier('haarcascade_car.xml')  # Update this path
        gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
        cars = car_cascade.detectMultiScale(gray, 1.1, 1)
        for (x, y, w, h) in cars:
            cv2.rectangle(image, (x, y), (x + w, y + h), (0, 0, 255), 2)
        return cars

    def highlight_vehicle_area(self, image, left_line, right_line, cars):
        overlay = image.copy()
        warning = False
        if left_line is not None and right_line is not None:
            height = image.shape[0]
            min_y = int(height * (3 / 5))
            max_y = int(height)

            left_x_start, left_y_start, left_x_end, left_y_end = left_line
            right_x_start, right_y_start, right_x_end, right_y_end = right_line

            pts = np.array([
                [left_x_start, left_y_start],
                [left_x_end, left_y_end],
                [right_x_end, right_y_end],
                [right_x_start, right_y_start]
            ], np.int32)

            cv2.fillPoly(overlay, [pts], (0, 255, 0))
            cv2.addWeighted(overlay, 0.3, image, 0.7, 0, image)

            for (x, y, w, h) in cars:
                car_center = (float(x + w // 2), float(y + h // 2))
                if cv2.pointPolygonTest(pts, car_center, False) >= 0:
                    warning = True

        if warning:
             cv2.putText(image, "Caution!! Vehicle Cutting In", (50, 50), cv2.FONT_HERSHEY_SIMPLEX, 1, (0, 0, 255), 2)
             cv2.putText(image, "Slow Down!!", (50, 100), cv2.FONT_HERSHEY_SIMPLEX, 1, (0, 0, 255), 2)


        return image

    def pipeline(self, image):
        height = image.shape[0]
        width = image.shape[1]
        region_of_interest_vertices = [
            (0, height),
            (width / 2, height / 2),
            (width, height),
        ]
        gray_image = cv2.cvtColor(image, cv2.COLOR_RGB2GRAY)
        cannyed_image = cv2.Canny(gray_image, 100, 200)

        cropped_image = self.region_of_interest(
            cannyed_image,
            np.array([region_of_interest_vertices], np.int32),
        )

        lines = cv2.HoughLinesP(
            cropped_image,
            rho=6,
            theta=np.pi / 60,
            threshold=160,
            lines=np.array([]),
            minLineLength=20,
            maxLineGap=300
        )

        left_line_x = []
        left_line_y = []
        right_line_x = []
        right_line_y = []

        if lines is not None:
            for line in lines:
                for x1, y1, x2, y2 in line:
                    slope = (y2 - y1) / (x2 - x1)
                    if math.fabs(slope) < 0.5:
                        continue
                    if slope <= 0:
                        left_line_x.extend([x1, x2])
                        left_line_y.extend([y1, y2])
                    else:
                        right_line_x.extend([x1, x2])
                        right_line_y.extend([y1, y2])

        if left_line_x and left_line_y:
            min_y = int(image.shape[0] * (3 / 5))
            max_y = int(image.shape[0])
            poly_left = np.poly1d(np.polyfit(left_line_y, left_line_x, deg=1))
            self.left_line = (int(poly_left(max_y)), max_y, int(poly_left(min_y)), min_y)

        if right_line_x and right_line_y:
            min_y = int(image.shape[0] * (3 / 5))
            max_y = int(image.shape[0])
            poly_right = np.poly1d(np.polyfit(right_line_y, right_line_x, deg=1))
            self.right_line = (int(poly_right(max_y)), max_y, int(poly_right(min_y)), min_y)

        # Draw the left and right lines on the image
        line_image = self.draw_lines(image, [[self.left_line], [self.right_line]], thickness=5)

        # Detect cars and draw red rectangles around them
        cars = self.detect_cars(line_image)

        # Highlight the area between the lanes and show warning if necessary
        final_image = self.highlight_vehicle_area(line_image, self.left_line, self.right_line, cars)

        return final_image

# Example usage
if _name_ == "_main_":
    lane_detector = LaneDetector()
    white_output = 'solidWhiteRight_output.mp4'
    clip1 = VideoFileClip("/content/Clip2.mp4")
    white_clip = clip1.fl_image(lane_detector.pipeline)
    white_clip.write_videofile(white_output, audio=False)